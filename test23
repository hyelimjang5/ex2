package test;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.Map;

public class test23 {

	//1. 로그파일 분석을 위한 변수
	//스레드명을 key, 시작시간...종료시간을 변수로 만든 클래스를 value로 사용해 만든 map
	static Map<String, logData> logMap = new LinkedHashMap<String, logData>();
	//종료시간을 구할 때 logMap을 logList에 add, logMap은 remove해 같은 스레드로 인해 logMap이 덮어씌지 않게 하기 위한 list
	static ArrayList<logData> logList = new ArrayList<>();
	//시작시간...종료시간을 변수로 만든 클래스
	static logData ld = null;
	//파일생성
	static BufferedWriter fw = null;
	static BufferedReader bReader = null;
	
	//2. 분별파일 분석을 위한 변수
	//분별을 key, 분별..시간,사이즈를 변수로 만든 클래스를 value로 사용해 만든 map
	static Map<String, logData2> logMap2 = new LinkedHashMap<String, logData2>();
	//파일에 있는 분만 추출한 list
	static ArrayList<String> minArr = new ArrayList<>();
	//분별..시간,사이즈를 변수로 만든 클래스
	static logData2 ld2 = null;

	public static void main(String[] args) {
		long start = System.currentTimeMillis();

		startLogAnalysis();//1. 로그파일 분석
		startLogAnalysis2();//2. 분별파일 분석

		long end = System.currentTimeMillis();

		System.out.println("실행 시간 : " + (end - start) +" ms");
		System.out.println(
				"Used Memory : " + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / 1000);

	}
	
	//2.분별파일분석
	private static void startLogAnalysis2() {
		BufferedReader bReader = null;
		BufferedReader bReader2 = null;
		try {
			String s;
			File file = new File("C:\\Users\\1911\\Desktop\\hyelim\\quiz\\test2_result\\logAnalysis2.txt");
			bReader = new BufferedReader(new FileReader(file));
			bReader2 = new BufferedReader(new FileReader(file));
			// 더이상 읽어들일게 없을 때까지 읽어들이게 합니다.
			//객체생성먼저
			while ((s = bReader.readLine()) != null) {
				 //System.out.println(s);
				//2-1. 분별로 minArr에 담기
				getMinArr(s);
				
				//2-2. 분별시간검색
				getTime(s);
			}
			//다음계산-객채생성과 동시에 계산을 하면 초기화 되기 때문에..
			while ((s = bReader2.readLine()) != null) {
				//2-3. 분별카운트
				getCount(s);
				
				//2-4. 평균소요시간(일단더해놓고 나중에 나누기)
				getAvgTime(s);
				
				//2-5. 최소시간
				getMinTime(s);
				
				//2-6. 최대시간
				getMaxTime(s);
				
				//2-7. 평균사이즈
				getAvgSize(s);
				
				//2-8. 최소사이즈
				getMinSize(s);
				
				//2-9. 최대사이즈
				getMaxSize(s);
			}
			//2-10.출력
			printData2();
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				if (bReader != null)
					bReader.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
	
	//2-1. 분별로 minArr에 담기
	private static void getMinArr(String s){

		if(!minArr.contains(s.substring(0, 14))){
			//System.out.println(s.substring(12,14));//분단위가 나오는 인덱스
			minArr.add(s.substring(0, 14));
		}

	}
	
	//2-2.분별시간검색
	private static void getTime(String s){
		//System.out.println(s.substring(12,14));
		
		for(int i=0;i<minArr.size();i++){
			ld2 = new logData2();
			ld2.setTime(minArr.get(i));
			//map에 저장
			logMap2.put(minArr.get(i), ld2);
			
		}
	
	}
	
	//2-3. 분별카운트
	private static void getCount(String s){
		//System.out.println(s.substring(0, 14));
		for(String key : logMap2.keySet()){
			if(s.substring(0,14).equals(key)){
				//System.out.println(s.substring(0,14));
				
				logData2 value = logMap2.get(key);

				value.setCnt(value.getCnt()+1);
				
			}
		}
	}
	
	//2-4. 평균소요시간(일단더해놓고 나중에 나누기)
	private static void getAvgTime(String s){

		try{
			SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss");
			Date d1 = sdf.parse(s.substring(9,17));//시작
			Date d2 = sdf.parse(s.substring(29,37));//끝
			long diff = d2.getTime() - d1.getTime();
			
			for(String key : logMap2.keySet()){
				logData2 value = logMap2.get(key);
				if(s.substring(0,14).equals(key)){
					value.setAvgTime(value.getAvgTime()+diff);
				}
			}
		}catch(Exception e){
			e.printStackTrace();
		}
	
	}
	
	//2-5. 최소시간
	private static void getMinTime(String s){

		try{
			SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss");
			Date d1 = sdf.parse(s.substring(9,17));//시작
			Date d2 = sdf.parse(s.substring(29,37));//끝
			long diff = d2.getTime() - d1.getTime();
			
			for(String key : logMap2.keySet()){
				logData2 value = logMap2.get(key);
				if(s.substring(0,14).equals(key)&&value.getMinTime()>diff){
					value.setMinTime(diff);
				}
			}
		}catch(Exception e){
			e.printStackTrace();
		}
	
	}
	
	//2-6. 최대시간
	private static void getMaxTime(String s){

		try{
			SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss");
			Date d1 = sdf.parse(s.substring(9,17));//시작
			Date d2 = sdf.parse(s.substring(29,37));//끝
			long diff = d2.getTime() - d1.getTime();
			
			for(String key : logMap2.keySet()){
				logData2 value = logMap2.get(key);
				if(s.substring(0,14).equals(key)&&value.getMaxTime()<diff){
					value.setMaxTime(diff);
				}
			}
		}catch(Exception e){
			e.printStackTrace();
		}
	
	}
	
	//2-7. 평균사이즈
	private static void getAvgSize(String s){
		//System.out.println(s.split(" , ")[3]);
		
		for(String key : logMap2.keySet()){
			logData2 value = logMap2.get(key);
			if(s.substring(0,14).equals(key)){
				value.setAvgSize(value.getAvgSize()+Integer.parseInt(s.split(" , ")[3]));
			}
		}

	}
	
	//2-8. 최소사이즈
	private static void getMinSize(String s){
		//System.out.println(s.split(" , ")[3]);
		
		for(String key : logMap2.keySet()){
			logData2 value = logMap2.get(key);
			if(s.substring(0,14).equals(key)&&
					(value.getMinSize()>Integer.parseInt(s.split(" , ")[3])||value.getMinSize()==0)){
				value.setMinSize(Integer.parseInt(s.split(" , ")[3]));
			}
		}

	}
	
	//2-9. 최대사이즈
	private static void getMaxSize(String s){
		//System.out.println(s.split(" , ")[3]);
		
		for(String key : logMap2.keySet()){
			logData2 value = logMap2.get(key);
			if(s.substring(0,14).equals(key)&&
					(value.getMaxSize()<Integer.parseInt(s.split(" , ")[3]))){
				value.setMaxSize(Integer.parseInt(s.split(" , ")[3]));
			}
		}

	}
	
	//2-10. 파일생성
	private static void printData2(){
	
		try{
			// 파일생성
			 File f = new File("C:\\\\Users\\1911\\Desktop\\hyelim\\quiz\\ex2_result\\logAnalysis2.txt");
			 fw = new BufferedWriter(new FileWriter(f, false));
			
			for(String key : logMap2.keySet()){
				logData2 value = logMap2.get(key);
				
				//평균시간계산
				value.setAvgTime(value.avgTime/value.cnt);
				
				//평균사이즈계산
				value.setAvgSize(value.avgSize/value.cnt);
				
				fw.write(value.time+" , "+value.cnt+" , "+value.avgTime+" , "+value.minTime+" , "+value.maxTime+" , "
						+value.avgSize+" , "+value.minSize+" , "+value.maxSize);
				fw.write("\r\n");
				fw.flush();
	
			}
		}catch(Exception e){
			e.printStackTrace();
		} finally {
			try {
				if (fw != null)
					fw.close();
				System.out.println("File saved!");
			} catch (IOException e) {
				e.printStackTrace();
			}
		}

	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	//1.로그파일분석
	private static void startLogAnalysis() {
		

		try {
			String s;
			File file = new File("C:\\Users\\1911\\Desktop\\hyelim\\quiz\\2.로그파일분석\\galileo.log");
			bReader = new BufferedReader(new FileReader(file));

			// 더이상 읽어들일게 없을 때까지 읽어들이게 합니다.
			while ((s = bReader.readLine()) != null) {
				// System.out.println(s);

				// 1.시작시간
				getStartTime(s);

				// 2.ESB_TRAN_ID
				if (s.indexOf("ESB_TRAN_ID : ") != -1) {
					getEsbId(s);
				}

				// 3.Content-Length
				if (s.indexOf("Content-Length:") != -1) {
					getConLen(s);
				}

				// 4. #galileo call time
				if (s.indexOf("#galileo call time:") != -1) {
					getCallTime(s);
				}

				// 5. running time
				StringBuffer sb = null;
				if (s.indexOf("]': running time") != -1) {
					// 5-1. Before Marshalling...unMarshalling까지 구하기 위해 StringBuffer를 이용해 한줄에 append함
					sb = getRunTimeStr(s);
					// 5-2. running time 각 소요시간
					getRunTime(sb.toString());
				}

				// 6. 종료시간
				if (s.indexOf("##galileo_bean end.") != -1) {
					getEndTime(s);
				}

			}

			//파일생성
			printData();

		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				if (bReader != null)
					bReader.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}

	// 1. 시작시간
	private static void getStartTime(String s) {

		if (s.indexOf("##galileo_bean start.") != -1) {
			ld = new logData();
			ld.setStartTime(s.substring(1, 18));
			logMap.put(s.substring(30, 66), ld);// map에 key(스레드명) value(시작시간)넣어줌

		}

	}

	// 2. ESB_TRAN_ID
	private static void getEsbId(String s) {
		
		for (String key : logMap.keySet()) {
			logData value = logMap.get(key);
			if (key.equals(s.substring(30, 66))) {

				value.setEsb_id(s.split("ESB_TRAN_ID : ")[1]);
			}
		}
	}

	// 3. Content-Length
	private static void getConLen(String s) {
		
		for (String key : logMap.keySet()) {
			logData value = logMap.get(key);
			if (key.equals(s.substring(30, 66))) {

				value.setCon_len(s.split("Content-Length:")[1]);
			}
		}
	}

	// 4. #galileo call time 추출
	private static void getCallTime(String s) {

		for (String key : logMap.keySet()) {
			logData value = logMap.get(key);
			if (key.equals(s.substring(30, 66))) {

				value.setCallTime(s.split("#galileo call time:")[1].split(" ms")[0]);
			}
		}
	}
	
	// 5-1. Before Marshalling...unMarshalling까지 구하기 위해 StringBuffer를 이용해 한줄에 append함
	private static StringBuffer getRunTimeStr(String s){
		StringBuffer sb = null;
		try{
			sb = new StringBuffer();
			
				sb.append(s);
				for (int i = 0; i < 7; i++) {
	
					sb.append(bReader.readLine());
					if (sb.indexOf("##") != -1) {
						break;
					}
				}
			
			
		}catch(Exception e){
			e.printStackTrace();
		}
		return sb;
	}

	// 5-2. running time 각 소요시간
	private static void getRunTime(String s) {
		
		for (String key : logMap.keySet()) {
			logData value = logMap.get(key);
			if (key.equals(s.substring(30, 66)) && s.contains("3. Invoking galileo")) {

				value.setRunTime1(s.split("-----------------------------------------")[2].substring(0, 5));
				value.setRunTime2(s.split("1. Before Marshalling")[1].substring(0, 5));
				value.setRunTime3(s.split("2. Marshalling")[1].substring(0, 5));
				value.setRunTime4(s.split("3. Invoking galileo")[1].substring(0, 5));
			}
		}
	}

	// 6. 종료시간
	private static void getEndTime(String s) {

		for (String key : logMap.keySet()) {
			logData value = logMap.get(key);
			if (key.equals(s.substring(30, 66))) {

				value.setEndTime(s.substring(1, 18));

				//온전하지 않은 데이터를 제거하기 위한 작업
				if(value.startTime!=null&&value.esb_id!=null&&value.con_len!=null
						&&value.callTime!=null&&value.runTime1!=null&&value.runTime2!=null
						&&value.runTime3!=null&&value.runTime4!=null&&value.endTime!=null){
					logList.add(value);
					
					logMap.remove(key);
					break;
				}
			}
		}
		
	}

	//파일생성
	private static void printData() {

		try{
			// 파일생성
			 File f = new File("C:\\\\Users\\1911\\Desktop\\hyelim\\quiz\\ex2_result\\logAnalysis1.txt");
			 fw = new BufferedWriter(new FileWriter(f, false));
			 
			 //종료시간을 구할때 list가 종료시간으로 정렬되어있기 때문에 시작시간 순으로 정렬하기 위한 메소드
			Collections.sort(logList);
			
			for(logData s:logList){

				fw.write(s.startTime + " , " + s.endTime + " , " + s.esb_id + " , " + s.con_len + " , "
							+ s.callTime + " , " + s.runTime1 + " , " + s.runTime2 + " , " + s.runTime3 + " , "
							+ s.runTime4 );
				fw.write("\r\n");
				fw.flush();
			}
		}catch(Exception e){
			e.printStackTrace();
		} finally {
			try {
				if (fw != null)
					fw.close();
				System.out.println("File saved!");
			} catch (IOException e) {
				e.printStackTrace();
			}
		}

	}

}
